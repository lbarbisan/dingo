package fr.umlv.ir.dingo.tools;

import fr.umlv.ir.dingo.tree.ArgsList;
import fr.umlv.ir.dingo.tree.BooleanExpr;
import fr.umlv.ir.dingo.tree.BooleanValue;
import fr.umlv.ir.dingo.tree.DefinitionExpr;
import fr.umlv.ir.dingo.tree.Expr;
import fr.umlv.ir.dingo.tree.FunctionCall;
import fr.umlv.ir.dingo.tree.Initialization;
import fr.umlv.ir.dingo.tree.Instruction;
import fr.umlv.ir.dingo.tree.Instructions;
import fr.umlv.ir.dingo.tree.NumericValue;
import fr.umlv.ir.dingo.tree.Param;
import fr.umlv.ir.dingo.tree.Params;
import fr.umlv.ir.dingo.tree.StringValue;

public interface GrammarEvaluator {
  public void dingo_start(Instructions instructions);
  public Instructions empty_instructions_def();
  public Instructions full_instructions_def(Instructions instructions, Instruction instruction);
  public Instruction instruction_expr_def(DefinitionExpr definitionExpr);
  public void full_var_keyword();
  public void empty_var_keyword();
  public DefinitionExpr empty_type_def_expr();
  public DefinitionExpr full_type_def_expr(String type);
  public DefinitionExpr init_def(Initialization initialization);
  public Initialization full_type_init_identifier_def(String type, Expr expr);
  public Initialization empty_type_init_identifier_def(Expr expr);
  public Expr numeric_expr_def();
  public Expr string_expr_def();
  public Expr function_call_expr_def(FunctionCall functionCall);
  public void identifier_numeric_def();
  public void identifier_string_def();
  public void string_value_def(StringValue stringValue);
  public void concat_def();
  public void plus_def();
  public void minus_def();
  public void star_def();
  public void divide_def();
  public void modulo_def();
  public void number_value_def(NumericValue numberValue);
  public Instruction if_def(BooleanExpr booleanExpr, Instructions instructions);
  public void empty_else_bloc();
  public void full_else_bloc(Instructions instructions);
  public BooleanExpr and_def(BooleanExpr booleanExpr, BooleanExpr booleanExpr2);
  public BooleanExpr or_def(BooleanExpr booleanExpr, BooleanExpr booleanExpr2);
  public BooleanExpr equals_def();
  public BooleanExpr not_equals_def();
  public BooleanExpr not_def(BooleanExpr booleanExpr);
  public BooleanExpr sup_def();
  public BooleanExpr inf_def();
  public BooleanExpr inf_equals_def();
  public BooleanExpr sup_equals_def();
  public BooleanExpr booleanValue_def(BooleanValue booleanValue);
  public Instruction for_def(Initialization initialization, BooleanExpr booleanExpr, Initialization initialization2, Instructions instructions);
  public Instruction foreach_def(Instructions instructions);
  public Instruction forever_def(Instructions instructions);
  public Instruction print_def(Expr expr);
  public Instruction println_def(Expr expr);
  public Instruction return_def(Expr expr);
  public Instruction break_def();
  public Instruction continue_def();
  public Instruction function_definition(String type, Params params_list, Instructions instructions);
  public Params empty_params_list();
  public Params param_list_def(Param param);
  public void empty_params_list_tail();
  public void full_params_list_tail(Param param);
  public Param param_def(String type);
  public String object_type_def();
  public String numeric_type_def();
  public String string_type_def();
  public String void_type_def();
  public String array_type_def(String type);
  public String function_type_def();
  public FunctionCall function_call_def(ArgsList args_list);
  public ArgsList empty_args_list();
  public ArgsList full_args_list(Expr arg);
  public void empty_args_list_tail();
  public void full_args_list_tail(Expr arg);
  public Expr arg_def(Expr expr);
}
