package fr.umlv.ir.dingo.tools;

import fr.umlv.ir.dingo.tools.GrammarEvaluator;
import fr.umlv.ir.dingo.tree.ArgsList;
import fr.umlv.ir.dingo.tree.BooleanExpr;
import fr.umlv.ir.dingo.tree.BooleanValue;
import fr.umlv.ir.dingo.tree.Expr;
import fr.umlv.ir.dingo.tree.ExprDefinition;
import fr.umlv.ir.dingo.tree.FunctionCall;
import fr.umlv.ir.dingo.tree.Identifier;
import fr.umlv.ir.dingo.tree.Instruction;
import fr.umlv.ir.dingo.tree.Instructions;
import fr.umlv.ir.dingo.tree.NumericValue;
import fr.umlv.ir.dingo.tree.Param;
import fr.umlv.ir.dingo.tree.ParamsList;

public interface GrammarEvaluator {
  public void dingo_start(Identifier identifier, Instructions instructions);
  public Instructions empty_instructions_def();
  public Instructions full_instructions_def(Instructions instructions, Instruction instruction);
  public Instruction instruction_expr_def(ExprDefinition expr_def);
  public void full_var_keyword();
  public void empty_var_keyword();
  public ExprDefinition empty_type_expr_def(Identifier identifier);
  public ExprDefinition full_type_expr_def(String type, Identifier identifier);
  public ExprDefinition init_def();
  public void full_type_init_identifier_def(String type, Identifier identifier, Expr expr);
  public void empty_type_init_identifier_def(Identifier identifier, Expr expr);
  public Expr numeric_expr_def();
  public Expr string_expr_def();
  public Expr function_call_expr_def(FunctionCall function_call);
  public void identifier_numeric_def();
  public void identifier_string_def();
  public void string_value_def(String stringValue);
  public void concat_def();
  public void plus_def();
  public void minus_def();
  public void star_def();
  public void divide_def();
  public void modulo_def();
  public void number_value_def(NumericValue numberValue);
  public Instruction if_def(BooleanExpr booleanExpr, Instructions instructions);
  public void empty_else_bloc();
  public void full_else_bloc(Instructions instructions);
  public BooleanExpr and_def(BooleanExpr booleanExpr, BooleanExpr booleanExpr2);
  public BooleanExpr or_def(BooleanExpr booleanExpr, BooleanExpr booleanExpr2);
  public BooleanExpr equals_def();
  public BooleanExpr not_equals_def();
  public BooleanExpr not_def(BooleanExpr booleanExpr);
  public BooleanExpr sup_def();
  public BooleanExpr inf_def();
  public BooleanExpr inf_equals_def();
  public BooleanExpr sup_equals_def();
  public BooleanExpr booleanValue_def(BooleanValue booleanValue);
  public Instruction for_def(BooleanExpr booleanExpr, Instructions instructions);
  public Instruction foreach_def(Identifier identifier, Identifier identifier2, Instructions instructions);
  public Instruction forever_def(Instructions instructions);
  public Instruction print_def(Expr expr);
  public Instruction println_def(Expr expr);
  public Instruction return_def(Expr expr);
  public Instruction break_def();
  public Instruction continue_def();
  public Instruction function_definition(String type, Identifier identifier, ParamsList params_list, Instructions instructions);
  public ParamsList empty_params_list();
  public ParamsList param_list_def(Param param);
  public void empty_params_list_tail();
  public void full_params_list_tail(Param param);
  public Param param_def(String type, Identifier identifier);
  public String object_type_def();
  public String numeric_type_def();
  public String string_type_def();
  public String void_type_def();
  public String array_type_def(String type);
  public String function_type_def();
  public FunctionCall function_call_def(ArgsList args_list);
  public ArgsList empty_args_list();
  public ArgsList full_args_list(Expr arg);
  public void empty_args_list_tail();
  public void full_args_list_tail(Expr arg);
  public Expr arg_def(Expr expr);
}
